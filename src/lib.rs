#![allow(non_snake_case)] // needed for autogenerated tuple unpacks

//! module documentation

// derive all types implemented by tuples
#[derive(
    Clone,
    Copy,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Debug,
    Default,
    Hash,
)]
/// Struct representing empty tuple list
///
/// # Examples
/// 
/// `EmptyTupleList` becomes empty tuple when converted to tuple:
/// 
/// ```rust
/// use tuple_list::EmptyTupleList;
/// use tuple_list::Tuple;
/// 
/// assert_eq!(().to_tuple_list(), EmptyTupleList)
/// ```
/// 
/// Empty tuple becomes `EmptyTupleList` when converted to tuple list:
/// 
/// ```rust
/// use tuple_list::EmptyTupleList;
/// use tuple_list::TupleList;
/// 
/// assert_eq!(EmptyTupleList.to_tuple(), ())
/// ```
pub struct EmptyTupleList;

/// Generic trait implemented by all tuple lists (up to 20 elements)
///
/// Can be used to convert tuple list to tuple
/// 
/// # Examples
/// 
/// ```rust
/// use crate::tuple_list::tuple_list;
/// use crate::tuple_list::TupleList;
/// use crate::tuple_list::EmptyTupleList;
/// 
/// let tuple_list = tuple_list!(1, false, String::from("abc"));
/// 
/// assert_eq!(
///     tuple_list.to_tuple(),
///     (1, false, String::from("abc")),
/// );
/// ```
pub trait TupleList {
    /// Tuple type corresponding to given tuple list
    type Tuple;

    /// Converts TupleList to tuple
    fn to_tuple(self) -> Self::Tuple;
}

/// Generic trait implemented by all tuples (up to 20 elements)
/// 
/// Can be used to convert tuple to tuple list
/// 
/// # Examples
/// 
/// ```rust
/// use crate::tuple_list::Tuple;
/// use crate::tuple_list::EmptyTupleList;
/// 
/// let tuple = (1, false, String::from("abc"));
/// 
/// assert_eq!(
///     tuple.to_tuple_list(), 
///     (1, (false, (String::from("abc"), EmptyTupleList))),
/// );
/// ```
pub trait Tuple {
    /// Tuple list type corresponding to given tuple
    type TupleList;

    /// Converts tuple to TupleList
    fn to_tuple_list(self) -> Self::TupleList;
}

// hack needed to work around rust macro limitations
// prepend value to tuple
trait TuplePrepend<Head> {
    type PrependedType;

    fn tuple_prepend(self, head: Head) -> Self::PrependedType;
}

// hack needed to work around rust macro limitations
// split tuple into head and tail
trait TupleCar {
    type HeadType;
    type TailType;

    fn tuple_car(self) -> (Self::HeadType, Self::TailType);
}

/// Macro creating tuple list from list of arguments
/// 
/// Can be used to create both values and types
/// 
/// # Examples
///
/// `tuple_list!()` becomes `EmptyTupleList`
/// 
/// `tuple_list!(i32)` becomes `(i32, EmptyTupleList)`
/// 
/// `tuple_list!(i32, bool)` becomes `(i32, (bool, EmptyTupleList))`
/// 
/// `tuple_list!("abc", 10, false)` becomes `("abc", (10, (false, EmptyTupleList)))`
/// 
/// # Code Examples
/// 
/// ```rust
/// use tuple_list::tuple_list;
/// use tuple_list::EmptyTupleList;
/// 
/// // using tuple_list! to define a value
/// let list1 = tuple_list!(1, false, String::from("foo"));
/// 
/// // using tuple_list! to define a type
/// let list2 : tuple_list!(i32, bool, String) = Default::default();
/// ```
#[macro_export]
macro_rules! tuple_list {
    () => ( EmptyTupleList );

    // handling types
    ($i:ident)  => ( ($i, EmptyTupleList) );
    ($i:ident,) => ( ($i, EmptyTupleList) );
    ($i:ident, $($e:ident),+)  => ( ($i, tuple_list!($($e),*)) );
    ($i:ident, $($e:ident),+,) => ( ($i, tuple_list!($($e),*)) );

    // handling values
    ($i:expr)  => ( ($i, EmptyTupleList) );
    ($i:expr,) => ( ($i, EmptyTupleList) );
    ($i:expr, $($e:expr),+)  => ( ($i, tuple_list!($($e),*)) );
    ($i:expr, $($e:expr),+,) => ( ($i, tuple_list!($($e),*)) );
}

// helper, returns first argument, ignores the rest
macro_rules! list_head {
    ($i:ident) => ( $i );
    ($i:ident, $($e:ident),+) => ( $i );
}

// helper, returns all arguments but the first one
macro_rules! list_tail {
    ($i:ident) => ( () );
    ($i:ident, $($e:ident),+) => ( ($($e),*,) );
}

// helper, converts tuple list into tuple
macro_rules! tuple_list_unpack {
    ($i:expr) => ( () );
    ($i:expr, $p:ident) => ( ($i.0, ) );
    ($i:expr, $p:ident, $($e:ident),+) => ( tuple_list_unpack!($i.1, $($e),*).tuple_prepend($i.0) );
}

// helper, converts tuple into tuple list
macro_rules! tuple_list_pack {
    ($i:expr) => ( EmptyTupleList );
    ($i:expr, $p:ident) => ( ($i.0, EmptyTupleList) );
    ($i:expr, $p:ident, $($e:ident),+) => ( { 
        let (head, tail) = $i.tuple_car();
        (head, tuple_list_pack!(tail, $($e),*))
    } );
}

// macro used to define `TuplePrepend`, `TupleCar`, `TupleList` and `Tuple` traits
macro_rules! define_tuple_list_traits {
    () => (
        impl<Head> TuplePrepend<Head> for () {
            type PrependedType = (Head,);
            fn tuple_prepend(self, head: Head) -> Self::PrependedType { (head,) }
        }
        impl TupleList for tuple_list!() {
            type Tuple = ();
            fn to_tuple(self) {}
        }
        impl Tuple for () {
            type TupleList = EmptyTupleList;
            fn to_tuple_list(self) -> EmptyTupleList { EmptyTupleList }
        }
    );

    ($($x:ident),*) => (
        impl<$($x),*, Head> TuplePrepend<Head> for ($($x),*,) {
            type PrependedType = (Head,$($x),*);
            fn tuple_prepend(self, head: Head) -> Self::PrependedType {
                let ($($x),*,) = self;
                return (head, $($x),*);
            }
        }
        impl<$($x),*> TupleCar for ($($x),*,) {
            type HeadType = list_head!($($x),*);
            type TailType = list_tail!($($x),*);
            fn tuple_car(self) -> (Self::HeadType, Self::TailType) {
                let ($($x),*,) = self;
                return (list_head!($($x),*), list_tail!($($x),*));
            }
        }
        impl<$($x),*> TupleList for tuple_list!($($x),*) {
            type Tuple = ($($x),*,);
            fn to_tuple(self) -> Self::Tuple {
                tuple_list_unpack!(self, $($x),*)
            }
        }
        impl<$($x),*> Tuple for ($($x),*,) {
            type TupleList = tuple_list!($($x),*);
            fn to_tuple_list(self) -> Self::TupleList {
                tuple_list_pack!(self, $($x),*)
            }
        }
    );
}

// defining traits for all tuples up to 20 elements
// add new lines as necessary
define_tuple_list_traits!();
define_tuple_list_traits!(T1);
define_tuple_list_traits!(T1, T2);
define_tuple_list_traits!(T1, T2, T3);
define_tuple_list_traits!(T1, T2, T3, T4);
define_tuple_list_traits!(T1, T2, T3, T4, T5);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20);

#[cfg(test)]
mod tests;