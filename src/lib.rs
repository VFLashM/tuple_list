#![allow(non_snake_case)] // needed for autogenerated tuple unpacks

//! module documentation
//! # Implementing recursive trait for tuple list
//! 
//! ```
//! use tuple_list::Tuple;
//! use tuple_list::TupleList;
//! 
//! // declare custom display-like trait 
//! trait Foo {
//!   fn foo(self) -> String;
//! }
//! 
//! // implement it for some builtin types
//! impl Foo for String { fn foo(self) -> String { format!("custom_str({})", self) } }
//! impl Foo for i32    { fn foo(self) -> String { format!("custom_int({})", self) } }
//! impl Foo for bool   { fn foo(self) -> String { format!("custom_bool({})", self) } }
//! 
//! // define initial condition
//! impl Foo for () {
//!   fn foo(self) -> String {
//!     String::new()
//!   }
//! }
//! 
//! // define trait recursion
//! impl<Head, Tail> Foo for (Head, Tail) where Head: Foo, Tail: Foo {
//!   fn foo(self) -> String {
//!     format!("{} {}", self.0.foo(), self.1.foo())
//!   }
//! }
//! 
//! // now trait can be used on arbitrary tuples
//! // whose elements implement CustomFormat
//! let tuple = (2, false, String::from("abc")); // tuples do not implement CustomFormat directly
//! let tuple_list = tuple.to_tuple_list();      // but can be converted to tuple list, which does
//! assert_eq!(
//!   tuple_list.foo(),
//!   "custom_int(2) custom_bool(false) custom_str(abc) ",
//! );
//! ```
//!
//! # Reasoning about tuples
//! 
//! ```rust
//! # use tuple_list::Tuple;
//! # use tuple_list::TupleList;
//! # trait Foo {
//! #   fn foo(self) -> String;
//! # }
//! # impl Foo for String { fn foo(self) -> String { format!("custom_str({})", self) } }
//! # impl Foo for i32    { fn foo(self) -> String { format!("custom_int({})", self) } }
//! # impl Foo for bool   { fn foo(self) -> String { format!("custom_bool({})", self) } }
//! # impl Foo for () {
//! #   fn foo(self) -> String {
//! #     String::new()
//! #   }
//! # }
//! # impl<Head, Tail> Foo for (Head, Tail) where Head: Foo, Tail: Foo {
//! #   fn foo(self) -> String {
//! #     format!("{} {}", self.0.foo(), self.1.foo())
//! #   }
//! # }
//! ```

// declare custom display-like trait 
trait Foo {
  fn foo(self) -> String;
}

// implement it for some builtin types
impl Foo for String { fn foo(self) -> String { format!("custom_str({})", self) } }
impl Foo for i32    { fn foo(self) -> String { format!("custom_int({})", self) } }
impl Foo for bool   { fn foo(self) -> String { format!("custom_bool({})", self) } }

// define initial condition
impl Foo for () {
  fn foo(self) -> String {
    String::new()
  }
}

// define trait recursion for type lists
/*
impl<Head, Tail> Foo for (Head, Tail) where Head: Foo, Tail: Foo {
  fn foo(self) -> String {
    format!("{} {}", self.0.foo(), self.1.foo())
  }
}
*/

// define trait recursion for regular tuples
impl<Head, Tail, T> Foo for T where Head: Foo, Tail: Tuple+Foo, T: TupleCons<Head=Head, Tail=Tail> {
    fn foo(self) -> String {
        let (head, tail) = self.uncons();
        return format!("{} {}", head.foo(), tail.foo());
    }
  }

#[test]
fn tuplefoo() {
    let tuple = (4 as i32, false, String::from("abc"));
    assert_eq!(tuple.foo(), "custom_int(4) custom_bool(false) custom_str(abc) ");
} 

/// Generic trait implemented by all tuple lists (up to 20 elements)
///
/// Can be used to convert tuple list to tuple
/// 
/// # Examples
/// 
/// ```rust
/// use crate::tuple_list::tuple_list;
/// use crate::tuple_list::TupleList;
/// 
/// let tuple_list = tuple_list!(1, false, String::from("abc"));
/// 
/// assert_eq!(
///     tuple_list.to_tuple(),
///     (1, false, String::from("abc")),
/// );
/// ```
pub trait TupleList {
    /// Tuple type corresponding to given tuple list
    type Tuple: Tuple;

    /// Converts TupleList to tuple
    fn to_tuple(self) -> Self::Tuple;
}

/// Generic trait implemented by all tuples (up to 20 elements)
/// 
/// Can be used to convert tuple to tuple list
/// 
/// # Examples
/// 
/// ```rust
/// use crate::tuple_list::Tuple;
/// 
/// let tuple = (1, false, String::from("abc"));
/// 
/// assert_eq!(
///     tuple.to_tuple_list(), 
///     (1, (false, (String::from("abc"), ()))),
/// );
/// ```
pub trait Tuple {
    /// Tuple list type corresponding to given tuple
    type TupleList: TupleList;

    /// Converts tuple to TupleList
    fn to_tuple_list(self) -> Self::TupleList;
}

/// Trait allowing you to convert
/// references to tuples into tuples of references
/// 
/// # Example
/// ```rust
/// use tuple_list::TupleAsRef;
/// 
/// fn by_val(tuple: (i32, i32)) {}
/// fn by_ref(tuple: (&i32, &i32)) {}
/// fn by_mut(tuple: (&mut i32, &mut i32)) {}
/// 
/// let mut tuple = (1, 2);
/// by_val(tuple);
/// by_ref(tuple.as_ref());
/// by_mut(tuple.as_mut());
/// ```
pub trait TupleAsRef<'a>: Tuple {
    type TupleOfRefs: Tuple;
    type TupleOfMutRefs: Tuple;

    /// Convertes reference to tuple into tuple of references
    fn as_ref(&'a self) -> Self::TupleOfRefs;

    /// Convertes mutable reference to tuple into tuple of mutable references
    fn as_mut(&'a mut self) -> Self::TupleOfMutRefs;
}

/// Trait allowing to cons/uncons tuples
///
/// unlike `Tuple` trait, it is not implemented
/// for empty tuples because they cannot be deconstructed
pub trait TupleCons: Tuple {
    type Head; /// first element of Self tuple
    type Tail: Tuple; /// remaining elements of Self tuple

    fn cons(head: Self::Head, tail: Self::Tail) -> Self;
    fn uncons(self) -> (Self::Head, Self::Tail);
    fn head(self) -> Self::Head;
    fn tail(self) -> Self::Tail;
}

/// Macro creating tuple list from list of arguments
/// 
/// See crate documentation for explanation of what tuple list is
/// 
/// # Examples
/// 
/// Can be used to define values:
/// 
/// ```rust
/// use tuple_list::tuple_list;
/// 
/// let list = tuple_list!(10, false, "foo");
/// 
/// assert_eq!(
///   list,
///   (10, (false, ("foo", ()))),
/// )
/// ```
/// 
/// To define types:
/// 
/// ```rust
/// # use tuple_list::tuple_list;
/// #
/// let list: tuple_list!(i32, bool, String) = Default::default();
/// 
/// assert_eq!(
///   list,
///   (00, (false, (String::new(), ()))),
/// )
/// ```
/// 
/// And to unpack existing values:
/// 
/// ```rust
/// # use tuple_list::tuple_list;
/// #
/// let tuple_list!(a, b, c) = (10, (false, ("foo", ())));
/// 
/// assert_eq!(a, 10);
/// assert_eq!(b, false);
/// assert_eq!(c, "foo");
/// ```
#[macro_export]
macro_rules! tuple_list {
    () => ( () );

    // handling types
    ($i:ident)  => ( ($i, ()) );
    ($i:ident,) => ( ($i, ()) );
    ($i:ident, $($e:ident),+)  => ( ($i, tuple_list!($($e),*)) );
    ($i:ident, $($e:ident),+,) => ( ($i, tuple_list!($($e),*)) );

    // handling values
    ($i:expr)  => ( ($i, ()) );
    ($i:expr,) => ( ($i, ()) );
    ($i:expr, $($e:expr),+)  => ( ($i, tuple_list!($($e),*)) );
    ($i:expr, $($e:expr),+,) => ( ($i, tuple_list!($($e),*)) );
    
    // handling types
    /*
    ($i:ty)  => ( ($i, ()) );
    ($i:ty,) => ( ($i, ()) );
    ($i:ty, $($e:ty),+)  => ( ($i, tuple_list!($($e),*)) );
    ($i:ty, $($e:ty),+,) => ( ($i, tuple_list!($($e),*)) );
    */
}

// helper, returns first argument, ignores the rest
macro_rules! list_head {
    ($i:ident) => ( $i );
    ($i:ident, $($e:ident),+) => ( $i );
}

// helper, returns all arguments but the first one
macro_rules! list_tail {
    ($i:ident) => ( () );
    ($i:ident, $e:ident) => ( ($e,) );
    ($i:ident, $($e:ident),+) => ( ($($e),*,) );
}

// helper, converts tuple list into tuple
macro_rules! tuple_list_unpack {
    ($i:expr) => ( () );
    ($i:expr, $p:ident) => ( ($i.0, ) );
    ($i:expr, $p:ident, $($e:ident),+) => ( TupleCons::cons($i.0, tuple_list_unpack!($i.1, $($e),*)) );
}

// helper, converts tuple into tuple list
macro_rules! tuple_list_pack {
    ($i:expr) => ( () );
    ($i:expr, $p:ident) => ( ($i.0, ()) );
    ($i:expr, $p:ident, $($e:ident),+) => ( { 
        let (head, tail) = $i.uncons();
        (head, tuple_list_pack!(tail, $($e),*))
    } );
}

// defines Tuple, TupleList, TupleCons and TupleAsRef
macro_rules! define_tuple_list_traits {
    () => (
        impl TupleList for () {
            type Tuple = ();
            fn to_tuple(self) {}
        }
        impl Tuple for () {
            type TupleList = ();
            fn to_tuple_list(self) {}
        }
        impl<'a> TupleAsRef<'a> for () {
            type TupleOfRefs = ();
            type TupleOfMutRefs = ();
            fn as_ref(&'a self) {}
            fn as_mut(&'a mut self) {}
        }
    );
    ($($x:ident),*) => (
        impl<$($x),*> TupleList for tuple_list!($($x),*) {
            type Tuple = ($($x),*,);
            fn to_tuple(self) -> Self::Tuple {
                tuple_list_unpack!(self, $($x),*)
            }
        }
        impl<$($x),*> Tuple for ($($x),*,) {
            type TupleList = tuple_list!($($x),*);
            fn to_tuple_list(self) -> Self::TupleList {
                tuple_list_pack!(self, $($x),*)
            }
        }
        impl<'a, $($x: 'a),*> TupleAsRef<'a> for ($($x),*,) {
            type TupleOfRefs = ($(&'a $x),*,);
            type TupleOfMutRefs = ($(&'a mut $x),*,);
            fn as_ref(&'a self) -> Self::TupleOfRefs {
                let ($($x),*,) = self;
                return ($($x),*,);
            }
            fn as_mut(&'a mut self) -> Self::TupleOfMutRefs {
                let ($($x),*,) = self;
                return ($($x),*,);
            }
        }
        impl<$($x),*> TupleCons for ($($x),*,) {
            type Head = list_head!($($x),*);
            type Tail = list_tail!($($x),*);
            fn cons(head: Self::Head, tail: Self::Tail) -> Self {
                let list_head!($($x),*) = head;
                let list_tail!($($x),*) = tail;
                return ($($x),*,);
            }
            fn uncons(self) -> (Self::Head, Self::Tail) {
                let ($($x),*,) = self;
                return (list_head!($($x),*), list_tail!($($x),*));
            }
            fn head(self) -> Self::Head { self.0 }
            fn tail(self) -> Self::Tail { self.uncons().1 }
        }
    );
}

// defining traits for all tuples up to 20 elements
// add new lines as necessary
define_tuple_list_traits!();
define_tuple_list_traits!(T1);
define_tuple_list_traits!(T1, T2);
define_tuple_list_traits!(T1, T2, T3);
define_tuple_list_traits!(T1, T2, T3, T4);
define_tuple_list_traits!(T1, T2, T3, T4, T5);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20);

#[cfg(test)]
mod tests;
