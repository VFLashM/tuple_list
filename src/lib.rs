#![allow(non_snake_case)] // needed for autogenerated tuple unpacks

//! module documentation
//! # Implementing recursive trait for tuple list
//! 
//! ```
//! use tuple_list::Tuple;
//! use tuple_list::TupleList;
//! use tuple_list::EmptyTupleList;
//! 
//! // declare custom display-like trait 
//! trait Foo {
//!   fn foo(self) -> String;
//! }
//! 
//! // implement it for some builtin types
//! impl Foo for String { fn foo(self) -> String { format!("custom_str({})", self) } }
//! impl Foo for i32    { fn foo(self) -> String { format!("custom_int({})", self) } }
//! impl Foo for bool   { fn foo(self) -> String { format!("custom_bool({})", self) } }
//! 
//! // define initial condition
//! impl Foo for EmptyTupleList {
//!   fn foo(self) -> String {
//!     String::new()
//!   }
//! }
//! 
//! // define trait recursion
//! impl<Head, Tail> Foo for (Head, Tail) where Head: Foo, Tail: Foo {
//!   fn foo(self) -> String {
//!     format!("{} {}", self.0.foo(), self.1.foo())
//!   }
//! }
//! 
//! // now trait can be used on arbitrary tuples
//! // whose elements implement CustomFormat
//! let tuple = (2, false, String::from("abc")); // tuples do not implement CustomFormat directly
//! let tuple_list = tuple.to_tuple_list();      // but can be converted to tuple list, which does
//! assert_eq!(
//!   tuple_list.foo(),
//!   "custom_int(2) custom_bool(false) custom_str(abc) ",
//! );
//! ```
//!
//! # Reasoning about tuples
//! 
//! ```rust
//! # use tuple_list::Tuple;
//! # use tuple_list::TupleList;
//! # use tuple_list::EmptyTupleList;
//! # trait Foo {
//! #   fn foo(self) -> String;
//! # }
//! # impl Foo for String { fn foo(self) -> String { format!("custom_str({})", self) } }
//! # impl Foo for i32    { fn foo(self) -> String { format!("custom_int({})", self) } }
//! # impl Foo for bool   { fn foo(self) -> String { format!("custom_bool({})", self) } }
//! # impl Foo for EmptyTupleList {
//! #   fn foo(self) -> String {
//! #     String::new()
//! #   }
//! # }
//! # impl<Head, Tail> Foo for (Head, Tail) where Head: Foo, Tail: Foo {
//! #   fn foo(self) -> String {
//! #     format!("{} {}", self.0.foo(), self.1.foo())
//! #   }
//! # }
//! ```

// declare custom display-like trait 
trait Foo {
  fn foo(self) -> String;
}

// implement it for some builtin types
impl Foo for String { fn foo(self) -> String { format!("custom_str({})", self) } }
impl Foo for i32    { fn foo(self) -> String { format!("custom_int({})", self) } }
impl Foo for bool   { fn foo(self) -> String { format!("custom_bool({})", self) } }

// define initial condition
impl Foo for () {
  fn foo(self) -> String {
    String::new()
  }
}

// define trait recursion for type lists
/*
impl<Head, Tail> Foo for (Head, Tail) where Head: Foo, Tail: Foo {
  fn foo(self) -> String {
    format!("{} {}", self.0.foo(), self.1.foo())
  }
}
*/

// define trait recursion for regular tuples
impl<Head, Tail, T> Foo for T where Head: Foo, Tail: TupleUncons+Foo, T: TupleUncons<Head=Head, Tail=Tail> {
    fn foo(self) -> String {
        let (head, tail) = self.uncons();
        return format!("{} {}", head.foo(), tail.foo());
    }
  }

// derive all types implemented by tuples
#[derive(
    Clone,
    Copy,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Debug,
    Default,
    Hash,
)]
/// Struct representing empty tuple list
///
/// # Examples
/// 
/// `EmptyTupleList` becomes empty tuple when converted to tuple:
/// 
/// ```rust
/// use tuple_list::EmptyTupleList;
/// use tuple_list::Tuple;
/// 
/// assert_eq!(().to_tuple_list(), EmptyTupleList)
/// ```
/// 
/// Empty tuple becomes `EmptyTupleList` when converted to tuple list:
/// 
/// ```rust
/// use tuple_list::EmptyTupleList;
/// use tuple_list::TupleList;
/// 
/// assert_eq!(EmptyTupleList.to_tuple(), ())
/// ```
pub struct EmptyTupleList;

/// Generic trait implemented by all tuple lists (up to 20 elements)
///
/// Can be used to convert tuple list to tuple
/// 
/// # Examples
/// 
/// ```rust
/// use crate::tuple_list::tuple_list;
/// use crate::tuple_list::TupleList;
/// use crate::tuple_list::EmptyTupleList;
/// 
/// let tuple_list = tuple_list!(1, false, String::from("abc"));
/// 
/// assert_eq!(
///     tuple_list.to_tuple(),
///     (1, false, String::from("abc")),
/// );
/// ```
pub trait TupleList {
    /// Tuple type corresponding to given tuple list
    type Tuple: Tuple;

    /// Converts TupleList to tuple
    fn to_tuple(self) -> Self::Tuple;
}

/// Generic trait implemented by all tuples (up to 20 elements)
/// 
/// Can be used to convert tuple to tuple list
/// 
/// # Examples
/// 
/// ```rust
/// use crate::tuple_list::Tuple;
/// use crate::tuple_list::EmptyTupleList;
/// 
/// let tuple = (1, false, String::from("abc"));
/// 
/// assert_eq!(
///     tuple.to_tuple_list(), 
///     (1, (false, (String::from("abc"), EmptyTupleList))),
/// );
/// ```
pub trait Tuple {
    /// Tuple list type corresponding to given tuple
    type TupleList: TupleList;

    /// Converts tuple to TupleList
    fn to_tuple_list(self) -> Self::TupleList;
}

/// Trait allowing you to convert
/// references to tuples into tuples of references
/// 
/// # Example
/// ```rust
/// use tuple_list::TupleAsRef;
/// 
/// fn by_val(tuple: (i32, i32)) {}
/// fn by_ref(tuple: (&i32, &i32)) {}
/// fn by_mut(tuple: (&mut i32, &mut i32)) {}
/// 
/// let mut tuple = (1, 2);
/// by_val(tuple);
/// by_ref(tuple.as_ref());
/// by_mut(tuple.as_mut());
/// ```
pub trait TupleAsRef<'a>: Tuple {
    type TupleOfRefs: Tuple;
    type TupleOfMutRefs: Tuple;

    /// Convertes reference to tuple into tuple of references
    fn as_ref(&'a self) -> Self::TupleOfRefs;

    /// Convertes mutable reference to tuple into tuple of mutable references
    fn as_mut(&'a mut self) -> Self::TupleOfMutRefs;
}

// hack needed to work around rust macro limitations
// prepend value to tuple
pub trait TupleCons<Head>: Tuple {
    type ResultType: Tuple;

    fn cons(head: Head, tail: Self) -> Self::ResultType;
}

// hack needed to work around rust macro limitations
// split tuple into head and tail
pub trait TupleUncons: Tuple {
    type Head;
    type Tail: Tuple;

    fn uncons(self) -> (Self::Head, Self::Tail);
    fn head(self) -> Self::Head;
    fn tail(self) -> Self::Tail;
}

/// Macro creating tuple list from list of arguments
/// 
/// Can be used to create both values and types
/// 
/// # Examples
///
/// `tuple_list!()` becomes `EmptyTupleList`
/// 
/// `tuple_list!(i32)` becomes `(i32, EmptyTupleList)`
/// 
/// `tuple_list!(i32, bool)` becomes `(i32, (bool, EmptyTupleList))`
/// 
/// `tuple_list!("abc", 10, false)` becomes `("abc", (10, (false, EmptyTupleList)))`
/// 
/// # Code Examples
/// 
/// ```rust
/// use tuple_list::tuple_list;
/// use tuple_list::EmptyTupleList;
/// 
/// // using tuple_list! to define a value
/// let list1 = tuple_list!(1, false, String::from("foo"));
/// 
/// // using tuple_list! to define a type
/// let list2 : tuple_list!(i32, bool, String) = Default::default();
/// ```
#[macro_export]
macro_rules! tuple_list {
    () => ( EmptyTupleList );

    // handling types
    ($i:ident)  => ( ($i, EmptyTupleList) );
    ($i:ident,) => ( ($i, EmptyTupleList) );
    ($i:ident, $($e:ident),+)  => ( ($i, tuple_list!($($e),*)) );
    ($i:ident, $($e:ident),+,) => ( ($i, tuple_list!($($e),*)) );

    // handling values
    ($i:expr)  => ( ($i, EmptyTupleList) );
    ($i:expr,) => ( ($i, EmptyTupleList) );
    ($i:expr, $($e:expr),+)  => ( ($i, tuple_list!($($e),*)) );
    ($i:expr, $($e:expr),+,) => ( ($i, tuple_list!($($e),*)) );
}

// helper, returns first argument, ignores the rest
macro_rules! list_head {
    ($i:ident) => ( $i );
    ($i:ident, $($e:ident),+) => ( $i );
}

// helper, returns all arguments but the first one
macro_rules! list_tail {
    ($i:ident) => ( () );
    ($i:ident, $($e:ident),+) => ( ($($e),*,) );
}

// helper, converts tuple list into tuple
macro_rules! tuple_list_unpack {
    ($i:expr) => ( () );
    ($i:expr, $p:ident) => ( ($i.0, ) );
    ($i:expr, $p:ident, $($e:ident),+) => ( TupleCons::cons($i.0, tuple_list_unpack!($i.1, $($e),*)) );
}

// helper, converts tuple into tuple list
macro_rules! tuple_list_pack {
    ($i:expr) => ( EmptyTupleList );
    ($i:expr, $p:ident) => ( ($i.0, EmptyTupleList) );
    ($i:expr, $p:ident, $($e:ident),+) => ( { 
        let (head, tail) = $i.uncons();
        (head, tuple_list_pack!(tail, $($e),*))
    } );
}

macro_rules! define_tuple_cons_trait {
    () => (
        impl<Head> TupleCons<Head> for () {
            type ResultType = (Head,);
            fn cons(head: Head, _: Self) -> Self::ResultType { (head,) }
        }
    );
    ($($x:ident),*) => (
        impl<$($x),*, Head> TupleCons<Head> for ($($x),*,) {
            type ResultType = (Head,$($x),*);
            fn cons(head: Head, tail: Self) -> Self::ResultType {
                let ($($x),*,) = tail;
                return (head, $($x),*);
            }
        }
    )
}

macro_rules! define_tuple_uncons_trait {
    () => (); // no uncons for empty list
    ($($x:ident),*) => (
        impl<$($x),*> TupleUncons for ($($x),*,) {
            type Head = list_head!($($x),*);
            type Tail = list_tail!($($x),*);
            fn uncons(self) -> (Self::Head, Self::Tail) {
                let ($($x),*,) = self;
                return (list_head!($($x),*), list_tail!($($x),*));
            }
            fn head(self) -> Self::Head { self.0 }
            fn tail(self) -> Self::Tail { self.uncons().1 }
        }
    );
}

// defines Tuple, TupleList and TupleAsRef
macro_rules! define_tuple_list_traits {
    () => (
        impl TupleList for EmptyTupleList {
            type Tuple = ();
            fn to_tuple(self) {}
        }
        impl Tuple for () {
            type TupleList = EmptyTupleList;
            fn to_tuple_list(self) -> EmptyTupleList { EmptyTupleList }
        }
        impl<'a> TupleAsRef<'a> for () {
            type TupleOfRefs = ();
            type TupleOfMutRefs = ();
            fn as_ref(&'a self) {}
            fn as_mut(&'a mut self) {}
        }
    );
    ($($x:ident),*) => (
        impl<$($x),*> TupleList for tuple_list!($($x),*) {
            type Tuple = ($($x),*,);
            fn to_tuple(self) -> Self::Tuple {
                tuple_list_unpack!(self, $($x),*)
            }
        }
        impl<$($x),*> Tuple for ($($x),*,) {
            type TupleList = tuple_list!($($x),*);
            fn to_tuple_list(self) -> Self::TupleList {
                tuple_list_pack!(self, $($x),*)
            }
        }
        impl<'a, $($x: 'a),*> TupleAsRef<'a> for ($($x),*,) {
            type TupleOfRefs = ($(&'a $x),*,);
            type TupleOfMutRefs = ($(&'a mut $x),*,);
            fn as_ref(&'a self) -> Self::TupleOfRefs {
                let ($($x),*,) = self;
                return ($($x),*,);
            }
            fn as_mut(&'a mut self) -> Self::TupleOfMutRefs {
                let ($($x),*,) = self;
                return ($($x),*,);
            }
        }
    );
}

macro_rules! define_all_traits {
    ($($x:ident),*) => (
        define_tuple_cons_trait!($($x),*);
        define_tuple_uncons_trait!($($x),*);
        define_tuple_list_traits!($($x),*);
    )
}

// defining traits for all tuples up to 20 elements
// add new lines as necessary
define_all_traits!();
define_all_traits!(T1);
define_all_traits!(T1, T2);
define_all_traits!(T1, T2, T3);
define_all_traits!(T1, T2, T3, T4);
define_all_traits!(T1, T2, T3, T4, T5);
define_all_traits!(T1, T2, T3, T4, T5, T6);
define_all_traits!(T1, T2, T3, T4, T5, T6, T7);
define_all_traits!(T1, T2, T3, T4, T5, T6, T7, T8);
define_all_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9);
define_all_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10);
define_all_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11);
define_all_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12);
define_all_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13);
define_all_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14);
define_all_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15);
define_all_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16);
define_all_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17);
define_all_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18);
define_all_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19);
// no cons trait for last tuple because otherwise it can't satisfy constraint for result type
define_tuple_uncons_trait!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20);
define_tuple_list_traits! (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20);

#[cfg(test)]
mod tests;