#![allow(non_snake_case)] // needed for autogenerated tuple unpacks

//! Crate for variadic tuple metaprogramming.
//! 
//! As of writing this crate, rust does not support variadic generics
//! and does not allow to reason about tuples in general.
//! 
//! Most importantly, rust does not allow one to generically
//! implement a trait for all tuples whose elements implement it.
//! 
//! This crate attempts to fill the gap by providing a way
//! to recursively define traits for tuples.
//! 
//! # Tuple lists
//! 
//! Tuple `(A, B, C, D)` can be unambiguously mapped into recursive tuple `(A, (B, (C, (D, ()))))`.
//! 
//! Unlike regular flat tuples, such recursive tuples can be effectively reasoned about in rust.
//! 
//! This crate calls such structures "tuple lists" and provides a set of traits and macros
//! allowing one to conveniently work with them.
//! 
//! # Tuple construction/deconstruction
//! 
//! `TupleCons` trait provides a way to construct/deconstruct tuples.
//! 
//! It is way less expressive than tuple lists, but in many cases it allows
//! to implement a trait on regular tuples by recursively deconstructing them.
//! 
//! # Examples
//! 
//! For examples please see README in source repository.

/// Trait providing conversion from tuple list into tuple.
///
/// Generic trait implemented for all tuple lists (up to 12 elements).
/// 
/// # Examples
/// 
/// ```
/// use crate::tuple_list::tuple_list;
/// use crate::tuple_list::TupleList;
/// 
/// let tuple_list = tuple_list!(1, false, String::from("abc"));
/// 
/// assert_eq!(
///     tuple_list.to_tuple(),
///     (1, false, String::from("abc")),
/// );
/// ```
pub trait TupleList {
    /// Tuple type corresponding to given tuple list
    type Tuple: Tuple;

    /// Converts TupleList to tuple
    fn to_tuple(self) -> Self::Tuple;
}

/// Trait providing conversion from tuple into tuple list.
/// 
/// Generic trait implemented for all tuples (up to 12 elements).
/// 
/// # Examples
/// 
/// ```
/// use crate::tuple_list::Tuple;
/// 
/// let tuple = (1, false, String::from("abc"));
/// 
/// assert_eq!(
///     tuple.to_tuple_list(), 
///     (1, (false, (String::from("abc"), ()))),
/// );
/// ```
pub trait Tuple {
    /// Tuple list type corresponding to given tuple.
    type TupleList: TupleList;

    /// Converts tuple into tuple list.
    fn to_tuple_list(self) -> Self::TupleList;
}

/// Trait providing conversion from references to tuples into tuples of references.
/// 
/// Generic trait implemented for all tuples (up to 12 elements).
/// 
/// # Example
/// ```
/// use tuple_list::TupleAsRef;
/// 
/// fn by_val(tuple: (i32, i32)) {}
/// fn by_ref(tuple: (&i32, &i32)) {}
/// fn by_mut(tuple: (&mut i32, &mut i32)) {}
/// 
/// let mut tuple = (1, 2);
/// by_val(tuple);
/// by_ref(tuple.as_ref());
/// by_mut(tuple.as_mut());
/// ```
pub trait TupleAsRef<'a>: Tuple {
    type TupleOfRefs: Tuple;
    type TupleOfMutRefs: Tuple;

    /// Convertes reference to tuple into tuple of references.
    fn as_ref(&'a self) -> Self::TupleOfRefs;

    /// Convertes mutable reference to tuple into tuple of mutable references.
    fn as_mut(&'a mut self) -> Self::TupleOfMutRefs;
}

/// Trait allowing to recursively construct/deconstruct tuples.
/// 
/// Generic trait implemented for all non-empty tuples (up to 12 elements).
/// 
/// Empty tuple does not implement this trait because it cannot be deconstructed.
pub trait TupleCons: Tuple {
    /// First element of `Self` tuple.
    type Head;
    /// Tuple of remaining elements of `Self` tuple.
    type Tail: Tuple;

    /// Prepends an element to a tuple.
    /// 
    /// It is not very useful on its own because it needs return type annotation,
    /// but it can be useful inside of highly generic code.
    /// 
    /// # Examples
    /// 
    /// ```
    /// use tuple_list::TupleCons;
    /// 
    /// let a: (i32,) = TupleCons::cons(4, ());
    /// assert_eq!(
    ///     a,
    ///     (4,),
    /// );
    /// 
    /// let b: (i32, bool) = TupleCons::cons(4, (false,));
    /// assert_eq!(
    ///     b,
    ///     (4, false),
    /// );
    /// 
    /// let c: (i32, bool, &str) = TupleCons::cons(4, (false, "foo"));
    /// assert_eq!(
    ///     c,
    ///     (4, false, "foo"),
    /// );
    /// ```
    fn cons(head: Self::Head, tail: Self::Tail) -> Self;

    /// Reverse of `TupleCons::cons`, splits `Self` tuple into first element and a remainder.
    /// 
    /// # Examples
    /// 
    /// ```
    /// use tuple_list::TupleCons;
    /// 
    /// let abcz = (4, false, "foo");
    /// let (a, bcz) = TupleCons::uncons(abcz);
    /// let (b, cz) = TupleCons::uncons(bcz);
    /// let (c, z)  = TupleCons::uncons(cz);
    /// 
    /// assert_eq!(a, 4);
    /// assert_eq!(b, false);
    /// assert_eq!(c, "foo");
    /// assert_eq!(z, ());
    /// ```
    fn uncons(self) -> (Self::Head, Self::Tail);

    /// Returns first element of a tuple.
    ///
    /// Same as `TupleCons::uncons().0`.
    fn head(self) -> Self::Head;

    /// Returns all but the first element of a tuple.
    /// 
    /// Same as `TupleCons::uncons().1`.
    fn tail(self) -> Self::Tail;
}

pub trait TupleConsRef<'a>: Tuple {
    type Head;
    type Tail: TupleAsRef<'a>;

    fn uncons_ref(&'a     self) -> (&'a     Self::Head, <<Self as TupleConsRef<'a>>::Tail as TupleAsRef<'a>>::TupleOfRefs);
    fn uncons_mut(&'a mut self) -> (&'a mut Self::Head, <<Self as TupleConsRef<'a>>::Tail as TupleAsRef<'a>>::TupleOfMutRefs);
}

/// Macro creating tuple list values from list of expressions.
/// 
/// # Examples
/// 
/// Main use of this macro is to create tuple list values:
/// 
/// ```
/// use tuple_list::tuple_list;
/// 
/// let list = tuple_list!(10, false, "foo");
/// 
/// assert_eq!(
///   list,
///   (10, (false, ("foo", ()))),
/// )
/// ```
/// 
/// Aside from that, `tuple_list!` can sometime be used to define trivial types,
/// but using macro `tuple_list_type!` is recommended instead:
/// 
/// ```
/// # use tuple_list::tuple_list;
/// # use std::collections::HashMap;
/// // trivial types work just fine with tuple_list!
/// let list: tuple_list!(i32, bool, String) = Default::default();
/// 
/// // more complex types will fail when using tuple_list!
/// // but will work with tuple_list_type!
/// use tuple_list::tuple_list_type;
/// 
/// let list: tuple_list_type!(
///     &'static str, 
///     HashMap<i32, i32>, 
///     <std::vec::Vec<bool> as IntoIterator>::Item,
/// ) = tuple_list!("foo", HashMap::new(), false);
/// ```
/// 
/// It can also be used to unpack tuples:
/// 
/// ```
/// # use tuple_list::tuple_list;
/// #
/// let tuple_list!(a, b, c) = (10, (false, ("foo", ())));
/// 
/// assert_eq!(a, 10);
/// assert_eq!(b, false);
/// assert_eq!(c, "foo");
/// ```
/// 
/// Unfortunately, due to rust macro limitations only simple, non-nested match patterns are supported.
#[macro_export]
macro_rules! tuple_list {
    () => ( () );

    // handling simple identifiers, for limited types and patterns support
    ($i:ident)  => ( ($i, ()) );
    ($i:ident,) => ( ($i, ()) );
    ($i:ident, $($e:ident),*)  => ( ($i, tuple_list!($($e),*)) );
    ($i:ident, $($e:ident),*,) => ( ($i, tuple_list!($($e),*)) );

    // handling complex expressions
    ($i:expr)  => ( ($i, ()) );
    ($i:expr,) => ( ($i, ()) );
    ($i:expr, $($e:expr),*)  => ( ($i, tuple_list!($($e),*)) );
    ($i:expr, $($e:expr),*,) => ( ($i, tuple_list!($($e),*)) );
}

/// Macro creating tuple list types from list of element types.
/// 
/// See macro `tuple_list!` for details.
#[macro_export]
macro_rules! tuple_list_type {
    () => ( () );
    
    ($i:ty)  => ( ($i, ()) );
    ($i:ty,) => ( ($i, ()) );
    ($i:ty, $($e:ty),*)  => ( ($i, tuple_list_type!($($e),*)) );
    ($i:ty, $($e:ty),*,) => ( ($i, tuple_list_type!($($e),*)) );
}

// helper, returns first argument, ignores the rest
macro_rules! list_head {
    ($i:ident) => ( $i );
    ($i:ident, $($e:ident),+) => ( $i );
}

// helper, returns all arguments but the first one
macro_rules! list_tail {
    ($i:ident) => ( () );
    ($i:ident, $e:ident) => ( ($e,) );
    ($i:ident, $($e:ident),+) => ( ($($e),*,) );
}

// helper, converts tuple list into tuple
macro_rules! tuple_list_unpack {
    ($i:expr) => ( () );
    ($i:expr, $p:ident) => ( ($i.0, ) );
    ($i:expr, $p:ident, $($e:ident),+) => ( TupleCons::cons($i.0, tuple_list_unpack!($i.1, $($e),*)) );
}

// helper, converts tuple into tuple list
macro_rules! tuple_list_pack {
    ($i:expr) => ( () );
    ($i:expr, $p:ident) => ( ($i.0, ()) );
    ($i:expr, $p:ident, $($e:ident),+) => ( { 
        let (head, tail) = $i.uncons();
        (head, tuple_list_pack!(tail, $($e),*))
    } );
}

// defines Tuple, TupleList, TupleCons and TupleAsRef
macro_rules! define_tuple_list_traits {
    () => (
        impl TupleList for () {
            type Tuple = ();
            fn to_tuple(self) {}
        }
        impl Tuple for () {
            type TupleList = ();
            fn to_tuple_list(self) {}
        }
        impl<'a> TupleAsRef<'a> for () {
            type TupleOfRefs = ();
            type TupleOfMutRefs = ();
            fn as_ref(&'a self) {}
            fn as_mut(&'a mut self) {}
        }
    );
    ($($x:ident),*) => (
        impl<$($x),*> TupleList for tuple_list_type!($($x),*) {
            type Tuple = ($($x),*,);
            fn to_tuple(self) -> Self::Tuple {
                tuple_list_unpack!(self, $($x),*)
            }
        }
        impl<$($x),*> Tuple for ($($x),*,) {
            type TupleList = tuple_list_type!($($x),*);
            fn to_tuple_list(self) -> Self::TupleList {
                tuple_list_pack!(self, $($x),*)
            }
        }
        impl<'a, $($x: 'a),*> TupleAsRef<'a> for ($($x),*,) {
            type TupleOfRefs = ($(&'a $x),*,);
            type TupleOfMutRefs = ($(&'a mut $x),*,);
            fn as_ref(&'a self) -> Self::TupleOfRefs {
                let ($($x),*,) = self;
                return ($($x),*,);
            }
            fn as_mut(&'a mut self) -> Self::TupleOfMutRefs {
                let ($($x),*,) = self;
                return ($($x),*,);
            }
        }
        impl<$($x),*> TupleCons for ($($x),*,) {
            type Head = list_head!($($x),*);
            type Tail = list_tail!($($x),*);
            fn cons(head: Self::Head, tail: Self::Tail) -> Self {
                let list_head!($($x),*) = head;
                let list_tail!($($x),*) = tail;
                return ($($x),*,);
            }
            fn uncons(self) -> (Self::Head, Self::Tail) {
                let ($($x),*,) = self;
                return (list_head!($($x),*), list_tail!($($x),*));
            }
            fn head(self) -> Self::Head { self.0 }
            fn tail(self) -> Self::Tail { self.uncons().1 }
        }
        impl<'a, $($x: 'a),*> TupleConsRef<'a> for ($($x),*,) {
            type Head = list_head!($($x),*);
            type Tail = list_tail!($($x),*);
            fn uncons_ref(&'a     self) -> (&'a     Self::Head, <<Self as TupleConsRef<'a>>::Tail as TupleAsRef<'a>>::TupleOfRefs) {
                let ($($x),*,) = self;
                return (list_head!($($x),*), list_tail!($($x),*));
            }
            fn uncons_mut(&'a mut self) -> (&'a mut Self::Head, <<Self as TupleConsRef<'a>>::Tail as TupleAsRef<'a>>::TupleOfMutRefs) {
                let ($($x),*,) = self;
                return (list_head!($($x),*), list_tail!($($x),*));
            }
        }
    );
}

// rust only defines common traits for tuples up to 12 elements
// we'll do the same here, increase number as needed
define_tuple_list_traits!();
define_tuple_list_traits!(T1);
define_tuple_list_traits!(T1, T2);
define_tuple_list_traits!(T1, T2, T3);
define_tuple_list_traits!(T1, T2, T3, T4);
define_tuple_list_traits!(T1, T2, T3, T4, T5);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11);
define_tuple_list_traits!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12);

#[cfg(test)]
mod tests;
